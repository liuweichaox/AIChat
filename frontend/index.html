<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>è¯­éŸ³åŠ©æ‰‹</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script type="module" src="https://unpkg.com/vue@3/dist/vue.esm-browser.js"></script>
</head>
<body>
  <div id="app">
    <h1>æ‚¨å¥½ï¼Œæˆ‘åœ¨</h1>

    <div class="history">
      <div v-for="(msg, idx) in history" :key="idx" :class="['message', msg.role]">
        {{ msg.text }}
      </div>
      <div class="message user" v-if="userText">{{ userText }}</div>
      <div class="message bot" v-if="reply.length">
        <span v-for="token in reply" :key="token.id" class="token">{{ token.text }}</span><span class="cursor" v-if="listening || typing">â–‹</span>
      </div>
    </div>

    <button @click="toggleMic">
      {{ recording ? 'â¹ åœæ­¢' : 'ğŸ™ å¼€å§‹è¯´è¯' }}
    </button>

    <div v-if="error" class="error">âš ï¸ {{ error }}</div>
  </div>

    <script type="module">
      import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

      createApp({
        setup() {
          const reply = ref([])
          const history = ref([])
          const userText = ref('')
          const recording = ref(false)
          const listening = ref(false)
          const typing = ref(false)
          const error = ref(null)
          let pc
          let ctrl
          let ttsChannel
          let localStream

          function playAudio(hex) {
            const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)))
            const blob = new Blob([bytes], { type: 'audio/wav' })
            const url = URL.createObjectURL(blob)
            const audio = new Audio(url)
            audio.onended = () => {
              setTimeout(() => {
                listening.value = true
                userText.value = ''
              }, 1000)
            }
            audio.play()
          }

        function typeReply(text) {
          reply.value = []
          typing.value = true
          let i = 0
          const timer = setInterval(() => {
            reply.value.push({ id: reply.value.length, text: text[i] })
            i++
            if (i >= text.length) {
              clearInterval(timer)
              typing.value = false
              history.value.push({ role: 'bot', text })
            }
          }, 50)
        }

        async function startCall() {
          reply.value = []
          history.value = []
          userText.value = ''
          recording.value = true
          listening.value = true
          error.value = null

          ctrl = new WebSocket(`ws://${location.host}/ws/control`)

          ctrl.onopen = async () => {
            pc = new RTCPeerConnection()
            ttsChannel = pc.createDataChannel('tts')
            ttsChannel.onmessage = (e) => {
              const msg = JSON.parse(e.data)
              if (msg.type === 'transcript') {
                userText.value = msg.data
                listening.value = false
                history.value.push({ role: 'user', text: msg.data })
              } else if (msg.type === 'text') {
                typeReply(msg.data)
              } else if (msg.type === 'audio') {
                playAudio(msg.data)
              }
            }

            localStream = await navigator.mediaDevices.getUserMedia({ audio: true })
            localStream.getTracks().forEach(t => pc.addTrack(t, localStream))

            const offer = await pc.createOffer()
            await pc.setLocalDescription(offer)

            const resp = await fetch('/rtc/offer', {
              method: 'POST',
              headers: { 'Content-Type': 'application/json' },
              body: JSON.stringify(pc.localDescription)
            })
            const ans = await resp.json()
            await pc.setRemoteDescription(new RTCSessionDescription(ans))
            ctrl.send(JSON.stringify({ type: 'register', id: ans.id }))
          }
        }

        function stopCall() {
          ctrl?.close()
          pc?.close()
          localStream?.getTracks().forEach(t => t.stop())
          recording.value = false
        }

        async function toggleMic() {
          if (recording.value) {
            stopCall()
          } else {
            try {
              await startCall()
            } catch (err) {
              error.value = err.message
              recording.value = false
            }
          }
        }

        return { reply, history, userText, recording, listening, typing, error, toggleMic }
      }
    }).mount('#app')
  </script>
</body>
</html>
