<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8" />
  <title>语音助手</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script type="module" src="https://unpkg.com/vue@3/dist/vue.esm-browser.js"></script>
</head>
<body>
  <div id="app">
    <h1>💬 实时语音对话</h1>

    <div class="reply">
      <div class="bot">
        <span v-for="token in reply" :key="token.id" class="token">{{ token.text }}</span>
        <span class="cursor" v-if="recording">▋</span>
      </div>
    </div>

    <button @click="toggleMic">
      {{ recording ? '⏹ 停止' : '🎙 开始说话' }}
    </button>

    <div v-if="error" class="error">⚠️ {{ error }}</div>
  </div>

  <script type="module">
    import { createApp, ref } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'

    createApp({
      setup() {
        const reply = ref([])
        const recording = ref(false)
        const error = ref(null)
        let ws
        let audioCtx
        let processor
        let stream
        function playAudio(hex) {
          const bytes = new Uint8Array(hex.match(/.{1,2}/g).map(b => parseInt(b, 16)))
          const blob = new Blob([bytes], { type: 'audio/wav' })
          const url = URL.createObjectURL(blob)
          new Audio(url).play()
        }

        async function startCall() {
          reply.value = []
          recording.value = true
          error.value = null

          ws = new WebSocket(`ws://${location.host}/ws/audio`)
          ws.binaryType = 'arraybuffer'
          ws.onmessage = (event) => {
            const msg = JSON.parse(event.data)
            if (msg.type === 'text') {
              reply.value.push({ id: reply.value.length, text: msg.data })
            } else if (msg.type === 'audio') {
              playAudio(msg.data)
            }
          }

          stream = await navigator.mediaDevices.getUserMedia({ audio: true })
          audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 16000 })
          const source = audioCtx.createMediaStreamSource(stream)
          processor = audioCtx.createScriptProcessor(4096, 1, 1)
          source.connect(processor)
          processor.connect(audioCtx.destination)
          processor.onaudioprocess = (e) => {
            if (!recording.value) return
            const input = e.inputBuffer.getChannelData(0)
            const pcm = new Int16Array(input.length)
            for (let i = 0; i < input.length; i++) {
              const s = Math.max(-1, Math.min(1, input[i]))
              pcm[i] = s < 0 ? s * 0x8000 : s * 0x7fff
            }
            ws.send(pcm.buffer)
          }
        }

        function stopCall() {
          ws?.close()
          processor?.disconnect()
          stream?.getTracks().forEach(t => t.stop())
          audioCtx?.close()
          recording.value = false
        }

        async function toggleMic() {
          if (recording.value) {
            stopCall()
          } else {
            try {
              await startCall()
            } catch (err) {
              error.value = err.message
              recording.value = false
            }
          }
        }

        return { reply, recording, error, toggleMic }
      }
    }).mount('#app')
  </script>
</body>
</html>
