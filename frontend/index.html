<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <title>è¯­éŸ³åŠ©æ‰‹</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script type="module" src="https://unpkg.com/vue@3/dist/vue.esm-browser.js"></script>
</head>

<body>
  <div id="app">
    <h1>æ¬¢è¿ä½¿ç”¨è¯­éŸ³åŠ©æ‰‹ï¼Œç‚¹å‡»å¼€å§‹è¯´è¯</h1>

    <div class="controls">
      <button @click="toggleMic">
        <span v-if="!recording">ğŸ™ å¼€å§‹</span>
        <span v-else>â¹ åœæ­¢</span>
      </button>

      <button class="icon secondary" @click="toggleSubtitles" :title="showSubtitles ? 'éšè—å­—å¹•' : 'æ˜¾ç¤ºå­—å¹•'">
        <!-- çœ¼ç› / çœ¼ç›åˆ’çº¿ SVG -->
        <svg v-if="showSubtitles" width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor"
          stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
          <path d="M1 12s4-8 11-8 11 8 11 8-4 8-11 8-11-8-11-8z"></path>
          <circle cx="12" cy="12" r="3"></circle>
        </svg>
        <svg v-else width="22" height="22" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"
          stroke-linecap="round" stroke-linejoin="round">
          <path
            d="M17.94 17.94A10.94 10.94 0 0 1 12 20c-7 0-11-8-11-8a21.76 21.76 0 0 1 5.06-6.94M9.9 4.24A10.94 10.94 0 0 1 12 4c7 0 11 8 11 8a21.83 21.83 0 0 1-3.19 4.62M1 1l22 22">
          </path>
        </svg>
      </button>

      <span class="badge" v-if="recording && listening">åœ¨å¬ä½ è¯´è¯â€¦</span>
      <span class="badge" v-if="typing">æœºå™¨äººå›å¤ä¸­â€¦</span>
    </div>

    <div class="history" ref="historyEl" :class="{ hidden: !showSubtitles }">
      <div v-for="(msg, idx) in history" :key="idx" :class="['message', msg.role]">
        {{ msg.text }}
      </div>
      <div class="message user" v-if="userText">{{ userText }}</div>
      <div class="message bot" v-if="reply.length">
        <span v-for="token in reply" :key="token.id" class="token">{{ token.text }}</span>
        <span class="cursor" v-if="listening || typing">â–‹</span>
      </div>
    </div>

    <div v-if="error" class="error">âš ï¸ {{ error }}</div>
  </div>

  <script type="module">
    import { createApp, ref, nextTick } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    createApp({
      setup() {
        const reply = ref([])
        const history = ref([])
        const userText = ref('')
        const recording = ref(false)
        const listening = ref(false)
        const typing = ref(false)
        const error = ref(null)
        const showSubtitles = ref(true)

        const historyEl = ref(null)
        let ws
        let audioCtx
        let localStream
        let workletNode

        function scrollToBottom() {
          nextTick(() => {
            if (historyEl.value) {
              historyEl.value.scrollTop = historyEl.value.scrollHeight
            }
          })
        }

        function playAudio(data) {
          if (!audioCtx) {
            audioCtx = new AudioContext({ sampleRate: 48000 })
          }
          if (data.byteLength === 0) return
          const pcm = new Int16Array(data)
          const float = new Float32Array(pcm.length)
          for (let i = 0; i < pcm.length; i++) float[i] = pcm[i] / 32768
          const buffer = audioCtx.createBuffer(1, float.length, 48000)
          buffer.copyToChannel(float, 0)
          const source = audioCtx.createBufferSource()
          source.buffer = buffer
          source.connect(audioCtx.destination)
          source.onended = () => {
            setTimeout(() => {
              listening.value = true
              userText.value = ''
            }, 300)
          }
          source.start()
        }

        function typeReply(text) {
          reply.value = []
          typing.value = true
          let i = 0
          const timer = setInterval(() => {
            reply.value.push({ id: reply.value.length, text: text[i] })
            scrollToBottom()
            i++
            if (i >= text.length) {
              clearInterval(timer)
              typing.value = false
              history.value.push({ role: 'bot', text })
              scrollToBottom()
            }
          }, 120)
        }

        async function startCall() {
          reply.value = []
          userText.value = ''
          recording.value = true
          listening.value = true
          error.value = null
          scrollToBottom()

          ws = new WebSocket(`ws://${location.host}/ws/audio`)
          ws.binaryType = 'arraybuffer'
          ws.onclose = () => { stopCall() }
          ws.onerror = (e) => { error.value = 'WebSocketé”™è¯¯'; console.error(e) }

          ws.onmessage = (e) => {
            if (typeof e.data === 'string') {
              const msg = JSON.parse(e.data)
              if (msg.type === 'transcript') {
                userText.value = msg.data
                listening.value = false
                history.value.push({ role: 'user', text: msg.data })
                scrollToBottom()
              } else if (msg.type === 'text') {
                typeReply(msg.data)
              }
            } else {
              playAudio(e.data)
            }
          }

          // å¿…é¡»ç”±ç”¨æˆ·æ‰‹åŠ¿è§¦å‘
          audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 })
          await audioCtx.audioWorklet.addModule('/static/pcm-processor.js')

          localStream = await navigator.mediaDevices.getUserMedia({ audio: true })
          const source = audioCtx.createMediaStreamSource(localStream)

          workletNode = new AudioWorkletNode(audioCtx, 'pcm-processor', { numberOfInputs: 1, numberOfOutputs: 0 })
          workletNode.port.onmessage = (ev) => {
            // ev.data: Int16Array
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(ev.data.buffer) // ç›´æ¥å‘ ArrayBuffer
            }
          }

          source.connect(workletNode)

          // iOS / Safari å¯èƒ½éœ€è¦
          if (audioCtx.state === 'suspended') {
            await audioCtx.resume()
          }
        }

        function stopCall() {
          try {
            ws && ws.readyState === WebSocket.OPEN && ws.close()
          } catch { }
          try {
            workletNode && workletNode.disconnect()
          } catch { }
          try {
            localStream?.getTracks().forEach(t => t.stop())
          } catch { }
          try {
            audioCtx && audioCtx.close()
          } catch { }
          recording.value = false
          listening.value = false
        }

        function toggleSubtitles() {
          showSubtitles.value = !showSubtitles.value
        }

        async function toggleMic() {
          if (recording.value) {
            stopCall()
          } else {
            try {
              await startCall()
            } catch (err) {
              console.error(err)
              error.value = err?.message || String(err)
              recording.value = false
            }
          }
        }

        return {
          reply, history, userText, recording, listening, typing, error,
          toggleMic, historyEl, showSubtitles, toggleSubtitles
        }
      }
    }).mount('#app')
  </script>
</body>

</html>