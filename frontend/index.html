<!DOCTYPE html>
<html lang="zh">

<head>
  <meta charset="UTF-8" />
  <title>è¯­éŸ³åŠ©æ‰‹</title>
  <link rel="stylesheet" href="/static/style.css" />
  <script type="module" src="https://unpkg.com/vue@3/dist/vue.esm-browser.js"></script>
</head>

<body>
  <div id="app" :class="{ square: showSubtitles }">
    <h1>æ¬¢è¿ä½¿ç”¨è¯­éŸ³åŠ©æ‰‹ï¼Œç‚¹å‡»ä¸‹æ–¹æŒ‰é’®å¼€å§‹å¯¹è¯</h1>

    <button @click="toggleSubtitles">
      {{ showSubtitles ? 'éšè—å­—å¹•' : 'æ˜¾ç¤ºå­—å¹•' }}
    </button>

    <div class="history" ref="historyEl" v-show="showSubtitles">
      <div v-for="(msg, idx) in history" :key="idx" :class="['message', msg.role]">
        {{ msg.text }}
      </div>
      <div class="message user" v-if="userText">{{ userText }}</div>
      <div class="message bot" v-if="reply.length">
        <span v-for="token in reply" :key="token.id" class="token">{{ token.text }}</span><span class="cursor"
          v-if="listening || typing">â–‹</span>
      </div>
    </div>

    <button @click="toggleMic">
      {{ recording ? 'â¹ åœæ­¢' : 'ğŸ™ å¼€å§‹è¯´è¯' }}
    </button>

    <div v-if="error" class="error">âš ï¸ {{ error }}</div>
  </div>

  <script type="module">
    import { createApp, ref, nextTick } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js'
    createApp({
      setup() {
        // å›å¤å†…å®¹çš„ token æ•°ç»„ï¼ˆé€å­—æ˜¾ç¤ºï¼‰
        const reply = ref([])
        // èŠå¤©å†å²è®°å½•ï¼ŒåŒ…å«ç”¨æˆ·å’Œæœºå™¨äººæ¶ˆæ¯
        const history = ref([])
        // å½“å‰ç”¨æˆ·è¯­éŸ³è½¬æ–‡å­—çš„å†…å®¹
        const userText = ref('')
        // æ˜¯å¦æ­£åœ¨å½•éŸ³ï¼ˆé€šè¯çŠ¶æ€ï¼‰
        const recording = ref(false)
        // æ˜¯å¦å¤„äºâ€œç­‰å¾…ç”¨æˆ·è¯´è¯â€çŠ¶æ€
        const listening = ref(false)
        // æ˜¯å¦æ­£åœ¨é€å­—è¾“å‡ºæœºå™¨äººå›å¤
        const typing = ref(false)
        // é”™è¯¯ä¿¡æ¯
        const error = ref(null)
        // æ˜¯å¦æ˜¾ç¤ºå­—å¹•
        const showSubtitles = ref(true)
        // WebSocket è¿æ¥
        let ws
        // éŸ³é¢‘å¤„ç†ç›¸å…³å¯¹è±¡
        let audioCtx
        let processor
        let localStream
        // èŠå¤©è®°å½•å®¹å™¨å…ƒç´ 
        const historyEl = ref(null)

        /**
         * å°†æ»šåŠ¨æ¡ç§»åˆ°åº•éƒ¨ï¼Œå§‹ç»ˆæ˜¾ç¤ºæœ€æ–°æ¶ˆæ¯
         */
        function scrollToBottom() {
          nextTick(() => {
            if (historyEl.value) {
              historyEl.value.scrollTop = historyEl.value.scrollHeight
            }
          })
        }

        /**
         * æ’­æ”¾ä»æœåŠ¡ç«¯è¿”å›çš„ PCM éŸ³é¢‘æ•°æ®
         * @param {ArrayBuffer} data - PCM æ•°æ®
         */
        function playAudio(data) {
          if (!audioCtx) {
            audioCtx = new AudioContext({ sampleRate: 48000 })
          }
          if (data.byteLength === 0) {
            return
          }
          const pcm = new Int16Array(data)
          const float = new Float32Array(pcm.length)
          for (let i = 0; i < pcm.length; i++) {
            float[i] = pcm[i] / 32768
          }
          const buffer = audioCtx.createBuffer(1, float.length, 48000)
          buffer.copyToChannel(float, 0)
          const source = audioCtx.createBufferSource()
          source.buffer = buffer
          source.connect(audioCtx.destination)
          source.onended = () => {
            setTimeout(() => {
              listening.value = true
              userText.value = ''
            }, 1000)
          }
          source.start()
        }

        /**
         * é€å­—æ˜¾ç¤ºæœºå™¨äººå›å¤å†…å®¹ï¼Œå¹¶åŠ å…¥å†å²
         * @param {string} text - æœºå™¨äººå›å¤æ–‡æœ¬
         */
        function typeReply(text) {
          reply.value = []
          typing.value = true
          let i = 0
          // æ¯150msæ˜¾ç¤ºä¸€ä¸ªå­—ç¬¦ï¼Œé€Ÿåº¦ä¸è¯­éŸ³æ’­æ”¾æ¥è¿‘
          const timer = setInterval(() => {
            reply.value.push({ id: reply.value.length, text: text[i] })
            scrollToBottom()
            i++
            if (i >= text.length) {
              clearInterval(timer)
              typing.value = false
              // å›å¤ç»“æŸååŠ å…¥å†å²
              history.value.push({ role: 'bot', text })
              scrollToBottom()
            }
          }, 150)
        }

        /**
        * å¼€å§‹ä¸€æ¬¡è¯­éŸ³ä¼šè¯ï¼Œåˆå§‹åŒ– WebSocket
         */
        async function startCall() {
          reply.value = []
          history.value = []
          userText.value = ''
          recording.value = true
          listening.value = true
          error.value = null
          scrollToBottom()

          ws = new WebSocket(`ws://${location.host}/ws/audio`)
          ws.binaryType = 'arraybuffer'
          ws.onmessage = (e) => {
            if (typeof e.data === 'string') {
              const msg = JSON.parse(e.data)
              if (msg.type === 'transcript') {
                userText.value = msg.data
                listening.value = false
                history.value.push({ role: 'user', text: msg.data })
                scrollToBottom()
              } else if (msg.type === 'text') {
                typeReply(msg.data)
              }
            } else {
              playAudio(e.data)
            }
          }

          localStream = await navigator.mediaDevices.getUserMedia({ audio: true })
          audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 48000 })
          const source = audioCtx.createMediaStreamSource(localStream)
          processor = audioCtx.createScriptProcessor(4096, 1, 1)
          source.connect(processor)
          processor.connect(audioCtx.destination)
          processor.onaudioprocess = (ev) => {
            if (ws.readyState !== WebSocket.OPEN) return
            const input = ev.inputBuffer.getChannelData(0)
            const buf = new ArrayBuffer(input.length * 2)
            const view = new DataView(buf)
            for (let i = 0; i < input.length; i++) {
              let s = Math.max(-1, Math.min(1, input[i]))
              view.setInt16(i * 2, s * 0x7fff, true)
            }
            ws.send(buf)
          }
        }

        /**
         * åœæ­¢è¯­éŸ³ä¼šè¯ï¼Œå…³é—­è¿æ¥å’ŒéŸ³é¢‘æµ
         */
        function stopCall() {
          ws?.close()
          processor?.disconnect()
          localStream?.getTracks().forEach(t => t.stop())
          recording.value = false
        }

        /**
         * åˆ‡æ¢å­—å¹•æ˜¾ç¤º/éšè—
         */
        function toggleSubtitles() {
          showSubtitles.value = !showSubtitles.value
        }

        /**
         * åˆ‡æ¢éº¦å…‹é£ï¼ˆå¼€å§‹/åœæ­¢ä¼šè¯ï¼‰
         */
        async function toggleMic() {
          if (recording.value) {
            // å·²åœ¨é€šè¯åˆ™åœæ­¢
            stopCall()
          } else {
            try {
              // å¦åˆ™å¼€å§‹æ–°ä¼šè¯
              await startCall()
            } catch (err) {
              // æ•è·å¼‚å¸¸å¹¶æ˜¾ç¤ºé”™è¯¯
              error.value = err.message
              recording.value = false
            }
          }
        }

        // æš´éœ²ç»™æ¨¡æ¿çš„æ•°æ®å’Œæ–¹æ³•
        return { reply, history, userText, recording, listening, typing, error, toggleMic, historyEl, showSubtitles, toggleSubtitles }
      }
    }).mount('#app')
  </script>
</body>

</html>